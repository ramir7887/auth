# Сквозной проект
## Пользовательская история

* Пользователь в браузере авторизуется на сервисе auth (эндпоинт /login) с помощью basic-авторизации. Для этого логины и хэш-суммы паролей должны быть заведены администратором в конфиг-файл сервиса auth. Сервис отправляет access jwt-куку клиенту, в которой содержится его логин, со сроком жизни 1 минута. Дополнительно к этому клиенту отправляется вспомогательная refresh-кука с токеном jwt, который тоже содержит логин пользователя. Кука refresh должна быть действительна в течение 1 часа. По истечении этого срока пользователь считается разлогиненным.
* При обращении на эндпоинт /i сервиса auth с переданной access-кукой пользователь может увидеть информацию о себе, полученную при аутентификации, пока это только логин пользователя.
* При обращении на /logout пользователь должен разлогиниться: клиенту передается установка пустых кук access и refresh.
* В каждом из запросов /login и /logout клиент может опционально указать путь редиректа после логина/логаута в query-параметре ?redirect_uri=... В этом случае сервис должен возвращать клиенту команду на редирект.

Все общение клиента с сервисом идет в архитектуре REST с форматом сообщений json.
## Реализация

Для сервиса auth:

* создать репозиторий и настроить его базовые параметры, линтеры, экшэны, прекомит-хуки
* создать http-сервер, выбрать и настроить базовый роутер
* создать эндпоинты /login, /logout, по которым сервис принимает авторизацию basic auth и возвращает куки access и refresh, содержащие jwt-токены
* по эндпоинту /i проверять jwt-куки на валидность и возвращать данные залогиненного пользователя (пока только логин). Предварительно jwt-токен должен быть провалидирован в мидлваре, разобран, и структура пользователя должна быть передана в хэндлер через контекст

## Дополнительные материалы

Подробнее о JWT

JSON Web Tokens — это открытый стандарт RFC 7519 для создания токенов доступа. Используется в передаче данных для аутентификации в клиент-серверных приложениях. В обычных небольших веб-приложениях легко идентифицировать пользователей с помощью сессий, но в микросервисной архитектуре и при высокой нагрузке сессии становятся малопригодными для использования. С помощью JWT мы можем создать уникальный токен для каждого аутентифицированного пользователя. Этот токен будет содержать необходимую информацию о пользователе, и будет включён в заголовок последующего запроса к API. Этот метод позволяет идентифицировать всех пользователей, которые выполняют вызовы API.

Давайте начнем с разбора самого JWT токена. Его содержимое представляет из себя ascii-строку, благодаря чему, может быть использован в качестве значения куки. По спецификации он содержит 3 блока: заголовки, набор кастомных полей (claims) и подпись, которые разделены через точку. Набор полей (claims) содержит произвольные пары имя/значения, однако стоит учитывать, что стандарт JWT имеет несколько зарезервированных имен. Первые два блока представлены в JSON-формате и дополнительно закодированы в формат base64. Подпись же вычисляется на основе первых двух блоков с помощью их хеширования по заданному в заголовке алгоритму, используя секретный ключ. Этим ключом также должен обладать и сервер, который впоследствии будет валидировать токен. Для валидации сервер выполняет тот же алгоритм калькуляции хеша подписи, и если они совпадают, считает токен валидным.

Более подробно можно прочитать здесь.

Обычно в Go используют библиотеку jwt-go для работы с jwt-токенами.
Напоминаем, что при сдаче каждого этапа проекта группа должна предоставить:

   * Успешно запущенные в K8S приложения

   * Успешно пройденные автоматизированные тесты (с помощью тестирующего сервиса)



Постман коллекция: https://gitlab.com/-/snippets/2346703 
